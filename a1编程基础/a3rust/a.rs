/*
一切为了 处理 赋值 中的内存资源管理

传统编程语言内存管理
py，js，go等 使用 垃圾回收机制（GC）当变量不会被使用时 回收 代价是降低了代码执行速度
c/c++ 使用 手动管理 缺点是可能会出现人为失误 造成内存溢出
rust 通过 规定书写格式 确保内存的管理

- 变量存放在哪里？
固定长变量 -> 栈内存
可变长变量 -> 栈内存（指针）+ 堆内存（资源值）

[原则：无回收机制，纯靠书写规则，确保内存管理]

0 变量的有效范围 = 作用域{}
1 作用域外
    变量 内存资源 被回收
    1-1 函数引用外部数据到自己的作用域，执行完后会把外部数据回收

2 作用域内
    变量 内存资源 一一对应
    2-1赋值，
    2-2创建同名变量，旧变量会被释放
    2-3 copy trait 函数传参时候 固定长变量会自动赋值，回收的是变量的副本
    2-4 clone赋值，直接复制一份内存资源

3 函数中使用 变量 且保证内存资源 不回收 也不想clone复制一份内存资源（降低效率）
    使用 引用
    引用是 指针，指向内存资源
    引用 不会复制内存资源，只复制指针
    为了防止 多个操作同时篡改数据
       3-1 有引用的时候 必须优先使用 引用 再使用 变量
       3-2 不可变引用 只能存在一个 可变引用可以存在多个

*/

fn main() {
    // 1-1 函数 回收 变量
    {
        let a = String::from("1-1 函数 作用域外 回收变量");
        fn test(a: String) {
            println!("{}", a);
        }
        test(a); // 此时 变量a 被回收
    }

    // 2-1 赋值 
    {
        let a = String::from("2-1 赋值");
        let b = a; // 此时 变量a 的 内存资源 被回收
        println!("{}", b);
    }

    // 2-2 重新声明 
    {
        let _a = 1;
        let _a = String::from("2-2 重新声明"); // 此时 变量a 的 内存资源 被回收
        println!("{}", _a);
    }

    // 2-3 copy trait       
    {
        let a :&str = "存在";
        let b :&str = a;      
        println!("2-3 copy trait: a:{} b:{}", a, b);
    }

    // 2-4 使用clone 赋值 避免原变量被回收
    { 
        let a = String::from("2-4 clone");
        let b = a.clone(); // 此时 变量a 的 内存资源 不会被回收
        println!("{}", b);
    }

    // 3 引用 
    {
        let mut a = String::from("3 引用");
        fn test(x: &mut String) {
            x.push_str("hh");
        }
        test(&mut a); // 此时 引用 没有被回收
        println!("{}", a);
    }





}
