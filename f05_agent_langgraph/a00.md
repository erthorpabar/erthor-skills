




- 路由route
1 链式
2 分支
3 循环(可返回上层节点)

- 工具
工具不要太多 llm容易混淆
============ 工具分层 =============
# 一级工具：粗粒度
@tool
def data_operations(operation: Literal["search", "create", "update"], **kwargs):
    """数据操作的入口"""
    if operation == "search":
        return search_tool(**kwargs)
    elif operation == "create":
        return create_tool(**kwargs)
    ...

# 二级工具：细粒度（内部调用）
def search_tool(...): ...
def create_tool(...): ...

============= 错误处理 ==================
@tool
def safe_api_call(endpoint: str, params: dict) -> str:
    """安全的 API 调用"""
    try:
        response = requests.get(endpoint, params=params, timeout=5)
        response.raise_for_status()
        return json.dumps(response.json())
    except requests.Timeout:
        return "ERROR: API 超时，请稍后重试"
    except requests.HTTPError as e:
        return f"ERROR: API 返回错误 {e.response.status_code}"
    except Exception as e:
        return f"ERROR: 未知错误 {str(e)}"


- 记忆

1 记忆实现
class ConversationState(TypedDict):
    messages: Annotated[list[BaseMessage], add]  # 关键：使用 add

def chat_node(state):
    # 所有历史消息都在 state["messages"]
    response = llm.invoke(state["messages"])
    return {"messages": [response]}  # 自动追加

# 执行过程：
# 第1轮: messages = [HumanMessage("你好")]
# 第2轮: messages = [HumanMessage("你好"), AIMessage("你好!"), HumanMessage("我叫Alice")]
# 第3轮: messages = [..., AIMessage("很高兴认识你，Alice")]

2 固定长度记忆
def trim_messages_node(state):
    messages = state["messages"]
    if len(messages) > 20:
        # 保留 system message + 最后15条
        system_msgs = [m for m in messages if m.type == "system"]
        recent_msgs = messages[-15:]
        return {"messages": system_msgs + recent_msgs}
    return {}

3 总结性记忆
def filter_by_relevance_node(state):
    current_query = state["messages"][-1].content
    history = state["messages"][:-1]

    # 计算相关性
    relevant_messages = []
    for msg in history:
        similarity = compute_similarity(current_query, msg.content)
        if similarity > 0.7:
            relevant_messages.append(msg)

    return {"messages": relevant_messages + [state["messages"][-1]]}

- 长期记忆 向量记忆
需求：记住用户的：

个人信息（姓名、偏好）
历史交互
任务状态
实现方式 1: 扩展状态
class StatefulAgentState(TypedDict):
    messages: Annotated[list[BaseMessage], add]
    user_profile: dict  # 用户画像
    preferences: dict   # 偏好设置
    task_history: list  # 任务历史

def update_profile_node(state):
    last_message = state["messages"][-1].content
    if "我叫" in last_message:
        name = extract_name(last_message)
        profile = state.get("user_profile", {})
        profile["name"] = name
        return {"user_profile": profile}
    return {}

实现方式 2: 外部存储（生产环境）
from langgraph.checkpoint import MemorySaver

# 内存存储（开发环境）
memory = MemorySaver()

app = graph.compile(checkpointer=memory)

# 使用线程 ID 区分不同用户
config = {"configurable": {"thread_id": "user_123"}}

# 第一次对话
app.invoke({"messages": [HumanMessage("我叫Alice")]}, config)

# 稍后的对话（同一用户）
app.invoke({"messages": [HumanMessage("我叫什么？")]}, config)
# Agent 能记住: "你叫 Alice"


2 
输入输出管道





# 健康检查
from fastapi import FastAPI

app = FastAPI()

@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "components": {
            "database": check_database(),
            "redis": check_redis(),
            "llm_api": check_llm_api()
        }
    }