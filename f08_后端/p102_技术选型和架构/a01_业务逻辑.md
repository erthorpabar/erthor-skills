
# 1 层级
1 业务逻辑 = 不同场景下 请求和数据的运行流程 实现思路
↓
2 技术选型 = 选择哪些技术
↓
3 高性能 = 高并发 低时延 高稳定性 易扩展 安全性 可监控


# 2 不同的业务特征
  业务特征         场景                                 原理                           技术
[数据]
1 数据存储        ETL/ELT 数据仓库                      写入数据库                      mysql postgresql mongodb
2 相似度          推荐 搜索 rag                         读取数据->召回(相似度)->排序     milvus faiss elasticsearch

[请求]
3 延迟计算        削峰填谷 高请求量(抢票 秒杀) 耗时计算   任务队列 (生产者-消费者 模式)     queue redis rabbitmq
4 实时通信        状态同步 聊天 游戏 任务进度追踪         消息队列 (sub-pub 模式)         queue+websocket redis rabbitmq
5 流式处理        实时性 推荐 监控 警告                  事件驱动                        kafka
6 定时请求        定时触发                              时间驱动                        celery apscheduler
[数据一致性]
6 读写一致性     多服务器对数据库同时增删改查            分布式锁 原子操作 保证同时只有一个能操作
7 事物一致性     支付 转账                             回滚(分布式结果一致) 幂等性(防重复提交)  

[巨量]
8 大量数据存储                                         全局id 分库分表
9 高频数据读取                                         数据缓存层                        redis
10 (非高频) 数据读取                                   负载均衡 + 主从集群 + 限流         nginx
11 突发大量请求                                        自动扩容水平扩展                   k8s

[服务器稳定性和安全]
12 备份
13 熔断
14 日志                                                                                 grafana

[其他细节]
登陆        jwt
心跳检测    websocket ping/pong
缓存一致性  先写入数据库再删缓存


锁
特性	      悲观锁	                乐观锁
加锁时机	  读取时加锁	             更新时检查
并发性能	  低（串行化）	           高（并发读）
适用场景	  冲突频繁、数据竞争激烈	  冲突较少、读多写少
数据库开销	较高（锁资源）	          较低
实现方式	  SELECT ... FOR UPDATE	  版本号/时间戳
等待机制	  阻塞等待	               失败重试


# 3 技术选型
# 1 后端框架 -> 对外提供服务
python-fastapi = 快速开发
go-gin = 高并发 高用户量
rust-axum = 并发量最高 最稳定 生态和企业使用尚不成熟
(grpc = 延迟最低 但调用配置复杂 不适合app直接使用)

# 2 数据库 -> 存储
数据库          数据格式    
mySQL          表
postgreSQL     表
redis          变量 key=value
mongodb        jsonl

# 3 队列 -> 1减少瞬时压力(延迟计算) 2同步消息
a -> 发送消息到队列 -> b接收
队列类型 	   生产者-消费者模式	    发布-订阅模式
queue       ✅ queue             ✅  queue + websocket
Redis	      ✅ List (BRPOP)	    ✅ Pub/Sub 或 Stream
RabbitMQ	  ✅ Queue 模式	      ✅ Exchange 模式（Fanout/Topic）
Kafka	      ✅ Consumer Group	  ✅ 多个 Consumer Group

# 4 向量数据库 -> 相似度
milvus
faiss



# 4 系统设计

# 1 发帖子系统(文字=(知乎 贴吧) 图文=(微博 小红书) 视频=(b站 抖音) )
mysql + redis缓存jwt登陆信息
用户 -> 登陆redis缓存jwt -> 帖子数据增删改查mysql 


# 2 延时计算任务(ai耗时生成 数据分析计算 限量抢购)
用户A(提交AI任务) ──┐                        ┌──> GPU主机1 ──┐                                            ┌──> client(ws实时消息传递) -> 用户A(APP)
用户B(提交AI任务) ──┼──> 任务队列 返回任务id──┼──> GPU主机2 ──┼──> 结果写入数据库 -> 广播队列(通知任务完成) ──┼──> client(ws实时消息传递) -> 用户B(APP)
用户C(提交AI任务) ──┘                        └──> GPU主机3 ──┘                                            └──> client(ws实时消息传递) -> 用户C(APP)

请求 ->redis(分布式锁) -> redis任务队列(生产者-消费者模式) -> redis消息队列状态跟踪(sub-pub模式) + ws_client



# 聊天室
                                                                               ┌──> client(ws实时消息传递) -> 用户B(接收)
用户A(消息) -> client(ws实时消息传递ping/pong) -> rabbitmq(rabbit sub-pub模式) ──┼──> client(ws实时消息传递) -> 用户C(接收)
                                                                               └──> client(ws实时消息传递) -> 用户D(接收)

# 量化交易
事件驱动系统 + apscheduler(定时任务)
# rag
milvus