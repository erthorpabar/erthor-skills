# 1 节点化流程
# 2 数据格式
(本质 = 一个公共数据表格 + 一些能够改变这些公共数据的函数交互)


# 1 发帖子系统 (文字=(知乎 贴吧) 图文=(微博 小红书) 视频=(b站 抖音) )
# 关键技术 = 长期数据库
用户A(APP) -> 浏览/发布帖子 ──> mysql数据库存储 ──> redis缓存热门内容 ──> 用户A(APP) 
# 1 发帖子系统 数据流转过程

## 数据流转 - 发帖流程
1 公共数据
用户会话池 = {user_id: jwt_token}
热门帖子缓存 = {post_id: {content, likes, views, author}}
帖子数据表 = posts(id, user_id, content, images, created_at, updated_at)
用户数据表 = users(id, username, avatar)

2 流程
1 用户登录 -> 验证身份 -> JWT存入Redis会话池 -> 返回token
2 用户发帖 -> 验证JWT -> 数据写入MySQL -> 返回帖子id
3 发帖成功 -> 如果是热门用户 -> 预加载到Redis缓存
4 其他用户浏览 -> 先查Redis缓存 -> 缓存未命中 -> 查MySQL -> 写入缓存 -> 返回数据

## 数据流转 - 浏览/交互流程
1 公共数据
浏览队列 = [{user_id, post_id, action: "view/like/comment", timestamp}]
热榜数据 = sorted_set{post_id: score(根据点赞数+浏览数计算)}

2 流程
1 用户浏览帖子 -> 记录到浏览队列 -> 异步批量写入MySQL
2 用户点赞/评论 -> Redis计数器+1 -> 异步更新MySQL
3 定时任务(每5分钟) -> 统计热门帖子 -> 更新热榜缓存
4 冷数据清理 -> 定期删除Redis中低频访问的帖子 -> 保留MySQL数据


# 2 聊天室 (多人实时交互 qq 微信 游戏 弹幕 会议 股价 定位)
# 关键技术 = 广播队列
                                                 ┌──> client(ws实时消息传递) -> 用户B(APP)
用户A(APP) -> client(ws实时消息传递) -> 广播队列 ──┼──> client(ws实时消息传递) -> 用户C(APP)
                                                 └──> client(ws实时消息传递) -> 用户D(APP)

# 2 聊天室系统 数据流转过程

## 数据流转 - 连接管理
1 公共数据
在线用户池 = {user_id: ws_connection_object}
房间用户映射 = {room_id: [user_id1, user_id2, user_id3...]}
消息广播队列 = {room_id: [{user_id, message, timestamp}]}

2 流程
1 用户连接 -> WebSocket握手 -> 验证JWT -> 加入在线用户池
2 用户加入房间 -> 添加到房间用户映射 -> 订阅该房间的消息队列
3 心跳检测 -> 每30秒ping/pong -> 超时断开 -> 从在线用户池移除
4 用户断开 -> 清理在线用户池 -> 清理房间用户映射

## 数据流转 - 消息发送与接收
1 公共数据
消息队列 = RabbitMQ/Redis Pub/Sub
消息格式 = {msg_id, room_id, user_id, content, msg_type, timestamp}
历史消息存储 = MongoDB/MySQL (可选持久化)

2 流程
1 用户A发送消息 -> 验证身份和权限 -> 消息发布到广播队列(room_id)
2 消息队列 -> 广播到所有订阅该room_id的WebSocket连接
3 在线用户B/C/D -> 通过WebSocket实时接收消息 -> 前端展示
4 离线用户E -> 消息存入历史消息存储 -> 标记未读
5 用户E上线 -> 查询未读消息 -> 推送到客户端 -> 标记已读

## 数据流转 - 消息持久化(可选)
1 公共数据
消息批量缓冲 = [{msg_id, room_id, user_id, content, timestamp}]
离线消息表 = offline_messages(id, user_id, msg_id, is_read)

2 流程
1 消息广播时 -> 同时写入批量缓冲
2 批量缓冲达到阈值(100条或5秒) -> 批量写入MongoDB
3 定时清理(7天) -> 删除过期历史消息 -> 保留重要消息
4 离线用户上线 -> 查询未读消息 -> 推送 -> 更新已读状态

# 3 ————————————————延时计算任务(ai耗时生成 数据分析计算 抢购)——————————————————
# 关键技术 = 任务队列 + 广播队列
用户A(提交AI任务) ──┐                         ┌──> GPU主机1 ──┐                                            ┌──> client(ws实时消息传递) -> 用户A(APP)
用户B(提交AI任务) ──┼──> 任务队列(返回任务id) ──┼──> GPU主机2 ──┼──> 结果写入数据库 -> 广播队列(通知任务完成) ──┼──> client(ws实时消息传递) -> 用户B(APP)
用户C(提交AI任务) ──┘                         └──> GPU主机3 ──┘                                            └──> client(ws实时消息传递) -> 用户C(APP)

# 节点运作流程过程
# 数据流转1
1 公共数据
任务队列 = [{id,data},{id,data}...]
执行队列 = [{id,data},{id,data}...]
成功队列 = [{id,data,success},{id,data,success}...]
失败队列 = [{id,data,failed},{id,data,failed}...]

2 流程
1 用户 -> 任务提交 任务队列 
2 多线程抓取任务执行 -> 放入 执行队列 
3 失败 -> 放入 失败队列 
4 成功 -> 放入 成功队列

# 数据流转2
1 公共数据
任务队列 = [{id,type,data},{id,type,data}...]
执行队列 = [{id,type,data},{id,type,data}...]
成功队列 = [{id,type,data,success},{id,type,data,success}...]
失败队列 = [{id,type,data,failed},{id,type,data,failed}...]

处理函数 = {type1:[func1,func2],type2:[func3,func4]}

2 流程
1 用户 -> 任务提交 任务队列 
2 多线程抓取任务执行 -> 放入 执行队列 
3 根据 type 匹配对应函数处理
4 失败 -> 放入 失败队列 
5 成功 -> 放入 成功队列

