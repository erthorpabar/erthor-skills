
# ————————————————————————用户体验————————————————————————
# 用户感知
1 0-200ms = 无感知 99%
2 200ms-1s = 有感知但可接受 99.99%
3 >1s = 有明显等待感觉

# 流量特点
1 平时流量
2 峰值流量(几倍-几十倍 平时流量)  

# ———————————————————————提高性能————————————————————————
# (应对平时流量)
# (提高架构达到高并发 -> 让系统结构更加复杂)


# 数据库 -> 读写量
                ┌──> 读写分离(主从库) 
预先构建连接池 ──┼──> 单表太大(分库分表)
                └──> 高频访问(高频数据缓存命中率)

主从库
一般1主3-5从 主负责写入 从负责读取 风险在于主从数据延迟

分库分表
id    name    age
1     aaa     11
2     bbb     22
3     ccc     33
4     ddd     44
通过唯一id 是否能被2整除判断在哪个表中
-表1
id    name    age
1     aaa     11
3     ccc     33
-表2
id    name    age
2     bbb     22
4     ddd     44



# server -> 实时交互计算
                     ┌──> 增加并发量 多机器(负载均衡) -> 更多机器(微服务架构)
单机(cpu利用率100%) ──┼
                     └──> 减少瞬时压力 延时计算(任务队列)

# 网速 -> 传输延迟
       ┌──> 扩充带宽
http ──┼
       └──> 减少延迟(rpc二进制传输)

# ——————————————————————扩展——————————————————————
# (应对峰值流量)
易扩展 -> server + 带宽
不易扩展 -> 数据库
1 应该优先考虑 流程中产量最小的地方 即 数据库
2 应该等比例扩容 避免 某节点成为新的瓶颈

# ——————————————————————稳定和易维护—————————————————————————
# 系统稳定性(长时间不停机 无故障)
1 超时 -> 性能监控
2 报错 -> 代码日志
3 容灾 -> 健康检测 自重启

# 代码复杂度 -> 代码风格
公共数据和变量
class1
class2
class3
1 类之间无嵌套 (局部面向对象编程)
2 类之间顺序执行 (整体面向过程编程)










